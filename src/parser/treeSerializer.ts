/**
 * Tree serializer - generates clean tree with V1 header/footer
 */

import { TreeNode } from "../types";

export class TreeSerializer {
  /**
   * Serialize tree to Markdown format (V1 explicit-operation mode)
   */
  static toMarkdown(
    tree: TreeNode,
    rootPath: string = "",
    folderName: string = "",
  ): string {
    const now = new Date();
    const dateStr = now.toLocaleString();

    let output = "";

    // Format version
    output += "<!-- FILETREEFORGE FORMAT v1 -->\n\n";

    // Header
    output += `# ROOT FOLDER : ${folderName || tree.name}\n`;
    output += `# GENERATED : ${dateStr}\n`;
    output += `# ROOT PATH : ${rootPath}\n\n`;

    // Tree body
    if (tree.children && tree.children.length > 0) {
      output += this.serializeChildren(tree.children, "");
    }

    // Footer (V1 explicit mode rules)
    output += "\n# Generated by FILETREEFORGE\n\n";
    output += "# Shortcuts\n";
    output += "# Ctrl + Shift + Enter → Preview\n";
    output += "# Ctrl + Enter → Apply Changes\n\n";
    output += "# RULES\n";
    output += "# - Use [+] to create files or folders\n";
    output += "# - Use [-] to delete files or folders\n";
    output += "# - Use [~ newName] to rename\n";
    output += "# - Structural edits without markers are NOT allowed\n";

    return output;
  }

  /**
   * Serialize children with tree symbols (no markers)
   */
  private static serializeChildren(
    children: TreeNode[],
    prefix: string,
  ): string {
    let output = "";

    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      const isLast = i === children.length - 1;

      const symbol = isLast ? "└─" : "├─";
      const childPrefix = isLast ? "   " : "│  ";

      const suffix = child.type === "folder" ? "/" : "";
      output += `${prefix}${symbol} ${child.name}${suffix}\n`;

      if (child.children && child.children.length > 0) {
        output += this.serializeChildren(child.children, prefix + childPrefix);
      }
    }

    return output;
  }
}
